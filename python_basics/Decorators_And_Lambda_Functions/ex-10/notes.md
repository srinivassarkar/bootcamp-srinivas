<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Multiple Decorators Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1 {
            color: #2c3e50;
        }
        pre {
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            overflow-x: auto;
        }
        .content {
            margin-bottom: 20px;
        }
        .note {
            background-color: #e7f3fe;
            border-left: 6px solid #2196F3;
            padding: 10px;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <h1>Python Multiple Decorators Example</h1>

    <div class="content">
        <h2>Problem Approach</h2>
        <p>This Python code demonstrates the use of multiple decorators to enhance the functionality of functions. The decorators include a simple logger, a timer, and a debug information logger.</p>
        
        <h3>Why?</h3>
        <p>Using decorators allows for the separation of concerns, enabling you to add functionality such as logging, timing, and debugging without modifying the original function code. This promotes code reusability and maintainability.</p>
        
        <h3>What?</h3>
        <p>The code defines three decorators: <code>simple_logger</code>, <code>timer</code>, and <code>debug_info</code>. Each decorator adds specific behavior to the functions they wrap. The <code>test_function</code> demonstrates how multiple decorators can be applied to a single function.</p>
        
        <h3>How?</h3>
        <p>Each decorator is defined as a function that takes another function as an argument. Inside each decorator, a wrapper function is defined that adds the desired behavior and calls the original function.</p>
    </div>

    <h2>Python Code</h2>
    <pre>
import time

def simple_logger(func):
    def wrapper(*args, **kwargs):
        print("Function started")
        result = func(*args, **kwargs)
        print("Function ended")
        return result
    return wrapper

@simple_logger
def greet(name):
    print(f"Hello, {name}!")

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"Execution time: {end - start:.4f} seconds")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(2)
    print("Function executed!")

# Example Usage
slow_function()

def debug_info(func):
    def wrapper(*args, **kwargs):
        print(f"Function: {func.__name__}, Args: {args}, Kwargs: {kwargs}")
        result = func(*args, **kwargs)
        print(f"Returned: {result}")
        return result
    return wrapper

@debug_info
def add(a, b):
    return a + b

print(add(5, 10))

@simple_logger
@timer
@debug_info
def test_function():
    time.sleep(1)
    print("Test function executed")

# Example Usage
test_function()
    </pre>

    <div class="note">
        <strong>Note:</strong> This code demonstrates how to use multiple decorators in Python to enhance function behavior, allowing for logging, timing, and debugging in a clean and maintainable way.
    </div>

</body>
</html>