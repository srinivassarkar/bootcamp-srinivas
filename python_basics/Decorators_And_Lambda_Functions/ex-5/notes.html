<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Debug Information Decorator Example</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1 {
            color: #2c3e50;
        }
        pre {
            background-color: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            overflow-x: auto;
        }
        .content {
            margin-bottom: 20px;
        }
        .note {
            background-color: #e7f3fe;
            border-left: 6px solid #2196F3;
            padding: 10px;
            margin-top: 20px;
        }
    </style>
</head>
<body>

    <h1>Python Debug Information Decorator Example</h1>

    <div class="content">
        <h2>Problem Approach</h2>
        <p>This Python code defines a decorator called <code>debug_info</code> that prints debug information about the function being called, including its name, arguments, keyword arguments, and the result it returns.</p>
        
        <h3>Why?</h3>
        <p>Debugging decorators are useful for tracking the flow of data through functions, making it easier to understand how inputs are transformed into outputs. This can help identify issues in the code during development.</p>
        
        <h3>What?</h3>
        <p>The <code>debug_info</code> decorator wraps the <code>add</code> function, logging the function's name, its arguments, and the result of the function call.</p>
        
        <h3>How?</h3>
        <p>The decorator is defined as a function that takes another function as an argument. Inside the decorator, a wrapper function is defined that adds the debugging behavior and calls the original function.</p>
    </div>

    <h2>Python Code</h2>
    <pre>
def debug_info(func):
    def wrapper(*args, **kwargs):
        print(f"Function: {func.__name__}, Args: {args}, Kwargs: {kwargs}")
        result = func(*args, **kwargs)
        print(f"Returned: {result}")
        return result
    return wrapper

@debug_info
def add(a, b):
    return a + b

# Example Usage
print(add(5, 10))  # Output: 15
    </pre>

    <div class="note">
        <strong>Note:</strong> This code demonstrates how to create a debugging decorator in Python to log function calls and their results, which can be invaluable for troubleshooting and understanding code behavior.
    </div>

</body>
</html>